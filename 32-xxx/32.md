##题目分析

给出一个括号串，求一个最长合法的连续括号子串。

###括号序列的性质

如果把括号序列看成一个数组，左括号当成1，右括号当成-1，$sum[0...n-1]$是这个序列的前缀和，那么他满足下面两个性质：

+ $sum[n-1]=0$
+ $min \left\{ sum[0...n-1] \right\} \geq 0$

正确性：

+ 第一点是显然的，一个合法的括号序列必然满足左括号数量等于右括号（即+1和-1的数量相等）
+ 假设$S，S'$都是一个合法括号序列，那么$(S)$和$SS'$也是合法序列，我们可以通过数学归纳法证明第二点性质：$()$显然满足第二点性质。假设$S$和$S'$满足第二点性质，那么$(S)$显然也满足（前缀和都+1，最后下标前缀和-1），$SS'$也显然满足（至少为大于等于0的前缀加上大于等于0的前缀，最终拼接的前缀序列也至少也大于等于0，并且末位仍然是0）。

###题解思路（1）

我们用$S[i...j]$表示原串中下标i到j之间的子串。那么可以通过$O(n^2)$枚举$(i,j)$，然后利用括号序列的前缀和性质$O(1)$判断$S[i...j]$，总复杂度$O(n^2)$。

###题解思路（2）

考虑到我们枚举一个下标i时，假设前缀和$sum[0...i-1]$等于pre，那么我们就相当于要在$S[i+1...n-1]$中找到一个下标j，使得$S[i...j]$满足:$sum[0...j]=pre$，$min \left\{ sum[0...k](i \leq k \leq j) \right\} \geq 0$。
到目前为止，可以想到这样一种策略：枚举一个下标i，想要在i+1~n-1这个范围内查找一个最大的下标j满足上述条件，如果能二分那就再好不过了。
幸运的是，我们可以利用RMQ这种数据结构，通过$O(nlgn)$的预处理实现$O(1)$的区间最值查询，实现二分的策略，具体如下：二分右下标j，每次查询$sum[i...j]$中的最小值，和pre进行比较，如果比pre大（右括号太多），那么降低上界，否则提高上界，这样下来便能确定一个唯一的最远边界j。
注意到一种特殊情况，比如串"()))))"，当我们枚举下标i，二分右下标j时，可以发现因为此时的i-1前缀为零（边界设定），右下标最终定在了n-1，这样的一个子串显然是不合法的，这是因为我们只关注到了引理中的性质2而忽视了性质1，这种情况的实际意义**就是当我们定下了i，无论怎么二分右下标j，都可以满足引理的性质2**，此时，只需要找到一个最靠右的下标j，使得$sum[0...j]==pre$即可。我们可以通过建立一个map来映射某个值val出现的最右位置即可。
这样算法总体复杂度控制在了$O(nlgn)$,比起前面的做法已经有了很大的改进。

####ps

怎样计算$S[i...j]$的前缀和呢？只需要计算出所有的$sum[0...k](0 \leq k < S.length)$,那么$sum[i...j]=sum[0...j]-sum[0...i-1](注意边界)$。

